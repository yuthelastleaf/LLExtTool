# LLExtTool 问题解决记录

## 1. Electron 启动时 Native 模块加载失败崩溃

### 问题描述
启动 Electron 时立即崩溃，提示 native C++ 模块加载失败。

### 根本原因
- Native 模块是用 Node.js v22 编译的（ABI 127）
- Electron 27.3.11 使用 Node.js v18.17.1（ABI 108）
- ABI 不匹配导致模块无法加载

### 解决方案
使用 `electron-rebuild` 工具重新编译 native 模块：
```bash
npm install --save-dev electron-rebuild
npx electron-rebuild
```

**关键点：**
- 必须使用 `electron-rebuild`，`cmake-js --runtime=electron` 编译的模块仍然会崩溃
- 只有 `electron-rebuild` 能生成与 Electron 兼容的 native 模块

---

## 2. llwhisper 模块编译时找不到 FFmpeg 头文件

### 问题描述
```
fatal error: libavcodec/avcodec.h: No such file or directory
```

### 根本原因
`electron-rebuild` 使用 `node-gyp`，只会在 `binding.gyp` 中指定的 include 路径查找头文件。Whisper.cpp 的头文件没有包含 FFmpeg 头文件。

### 解决方案
在编译前将 FFmpeg 头文件复制到 `whisper.cpp/include/` 目录：

```javascript
// scripts/build-native.js
const ffmpegInclude = path.join(nativeDir, 'ffmpeg', 'include');
const whisperInclude = path.join(nativeDir, 'whisper.cpp', 'include');

// 复制 FFmpeg 头文件
fs.cpSync(ffmpegInclude, whisperInclude, { recursive: true });
```

然后更新 `binding.gyp`：
```gyp
"include_dirs": [
  "native/whisper.cpp/include",      # 包含 FFmpeg 头文件
  "native/whisper.cpp/ggml/include"
]
```

---

## 3. whisper.lib 链接路径错误

### 问题描述
```
LINK : fatal error LNK1181: cannot open input file '../native/whisper.cpp/bin/Release/whisper.lib'
```

### 根本原因
Whisper.cpp 用 CMake 构建后，库文件在 `build/src/Release/whisper.lib`，但 `binding.gyp` 中指定的是 `bin/Release/whisper.lib`。

### 解决方案
修改 `binding.gyp` 中的库路径：
```gyp
"libraries": [
  "../native/whisper.cpp/build/src/Release/whisper.lib"  # 正确路径
]
```

---

## 4. 运行时缺少 GGML DLL 文件

### 问题描述
```
The specified module could not be found: ggml-cuda.dll
```

### 根本原因
Whisper.cpp 使用 CUDA 加速时，需要额外的 GGML DLL 文件，但这些文件没有被复制到输出目录。

### 解决方案
在 `binding.gyp` 的 `copies` 部分添加 GGML DLL：
```gyp
"copies": [{
  "destination": "<(module_root_dir)/build/Release",
  "files": [
    "native/whisper.cpp/build/bin/ggml-cuda.dll",  # 26.9MB CUDA 后端
    "native/whisper.cpp/build/bin/ggml.dll",       # 66KB 主库
    "native/whisper.cpp/build/bin/ggml-base.dll",  # 519KB 基础库
    "native/whisper.cpp/build/bin/ggml-cpu.dll",   # CPU 后端
    # FFmpeg DLLs...
  ]
}]
```

---

## 5. FFmpeg DLL 版本不匹配

### 问题描述
运行时提示找不到 `avcodec-60.dll` 等文件。

### 根本原因
使用的 FFmpeg 是新版本（BtbN builds），DLL 文件名是 `avcodec-61.dll`, `avformat-61.dll` 等，但 `binding.gyp` 中配置的是旧版本号。

### 解决方案
更新 `binding.gyp` 中的 DLL 文件名：
```gyp
"files": [
  "native/ffmpeg/bin/avcodec-61.dll",    # 60 → 61
  "native/ffmpeg/bin/avformat-61.dll",   # 60 → 61
  "native/ffmpeg/bin/avutil-59.dll",     # 58 → 59
  "native/ffmpeg/bin/swresample-5.dll",  # 4 → 5
  # ...
]
```

---

## 6. Whisper 模型路径配置为空

### 问题描述
首次启动时，配置文件中 `whisperModelPath` 为空字符串，导致无法加载模型。

### 根本原因
`config-manager.ts` 中默认配置没有设置模型路径。

### 解决方案
在 `config-manager.ts` 中自动检测默认模型路径：
```typescript
const defaultModelPath = path.join(
  appRoot, 
  'native', 
  'whisper.cpp', 
  'models', 
  'ggml-large-v2-f16.bin'
);

const defaultConfig: AppConfig = {
  whisperModelPath: fs.existsSync(defaultModelPath) ? defaultModelPath : '',
  // ...
};
```

---

## 7. "添加说话人"按钮无法点击

### 问题描述
点击"添加说话人"按钮没有任何反应。

### 根本原因
函数定义上方的中文注释使用了 `//` 格式：
```typescript
// 添加说话人
function addSpeaker() { ... }
```

在 Windows 中文环境下，`//` 注释可能因编码问题导致后续代码被当作注释，函数定义失效。

### 解决方案
将所有 `//` 中文注释改为 `/** */` 格式：
```typescript
/**
 * 添加说话人
 */
function addSpeaker() { ... }
```

---

## 8. 文件选择和设置对话框无法弹出

### 问题描述
点击"选择视频"、"设置"等按钮时，对话框不会弹出。

### 根本原因 1：mainWindow 引用问题
`main.ts` 中导出的 `mainWindow` 是一个 `let` 变量：
```typescript
let mainWindow: BrowserWindow | null = null;
export { mainWindow };  // 导出的是初始值 null
```

当窗口创建后，`mainWindow` 被赋新值，但导出的引用仍然是 `null`。

### 解决方案 1
使用 getter 函数而不是直接导出变量：
```typescript
// main.ts
let mainWindow: BrowserWindow | null = null;

export function getMainWindow(): BrowserWindow | null {
  return mainWindow;
}

// ipc-handlers.ts
import { getMainWindow } from './main';

ipcMain.handle(IpcChannels.SELECT_VIDEO, async () => {
  const mainWindow = getMainWindow();  // 获取当前窗口引用
  if (!mainWindow) return null;
  const result = await dialog.showOpenDialog(mainWindow, { ... });
  // ...
});
```

### 根本原因 2：dialog.showOpenDialog 缺少父窗口参数
Electron 的 `dialog.showOpenDialog()` 需要传入父窗口，否则对话框可能不显示：
```typescript
// 错误：没有父窗口
const result = await dialog.showOpenDialog({ ... });

// 正确：传入父窗口
const result = await dialog.showOpenDialog(mainWindow, { ... });
```

---

## 9. 渲染进程 Console 没有日志输出

### 问题描述
添加了 `console.log()` 但控制台中看不到任何输出。

### 根本原因
编译后的 `renderer.js` 是 CommonJS 格式，开头有：
```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
```

在浏览器环境中（即使设置了 `nodeIntegration: true`），全局作用域中没有 `exports` 对象，导致脚本执行失败：
```
Uncaught ReferenceError: exports is not defined at renderer.js:2:23
```

### 解决方案
在 HTML 中加载脚本前，先定义 `exports` 和 `module` 对象：
```html
<script>
    // 为 CommonJS 模块提供全局对象
    if (typeof exports === 'undefined') {
        var exports = {};
    }
    if (typeof module === 'undefined') {
        var module = { exports: exports };
    }
</script>
<script src="renderer.js"></script>
```

---

## 10. 调试时代码没有更新

### 问题描述
修改代码后，按 F5 调试或运行 `npm run dev`，但执行的仍是旧代码。

### 根本原因
- `npm run dev` 使用 watch 模式，可能没有正确触发重新编译
- TypeScript 源码修改后需要重新编译成 JavaScript

### 解决方案
**方法 1：** 使用 `npm start`（推荐）
```bash
npm run build && npm start
```
这会先编译再启动，保证代码是最新的。

**方法 2：** 配置 VS Code 调试
创建 `.vscode/launch.json`：
```json
{
  "configurations": [{
    "name": "调试 Electron 主进程",
    "type": "node",
    "request": "launch",
    "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron.cmd",
    "args": ["."],
    "preLaunchTask": "npm: build"  // 启动前先编译
  }]
}
```

创建 `.vscode/tasks.json`：
```json
{
  "tasks": [{
    "type": "npm",
    "script": "build",
    "label": "npm: build",
    "options": {
      "shell": {
        "executable": "cmd.exe",  // 避免 PowerShell 执行策略问题
        "args": ["/c"]
      }
    }
  }]
}
```

**方法 3：** 渲染进程刷新
如果只修改了渲染进程代码，编译后在开发者工具中按 `Ctrl+R` 刷新页面即可。

---

## 总结

### 关键技术点

1. **Native 模块编译**：必须使用 `electron-rebuild`，确保 ABI 匹配
2. **头文件管理**：将依赖的头文件复制到统一目录
3. **DLL 依赖**：所有运行时需要的 DLL 必须在 `binding.gyp` 中声明并复制
4. **模块导出**：在 Electron 中，主进程和渲染进程之间传递引用要用函数而不是直接导出变量
5. **CommonJS 兼容**：渲染进程使用 CommonJS 模块时，需要在 HTML 中提前定义 `exports` 和 `module`
6. **中文编码**：避免在 TypeScript 中使用 `//` 格式的中文注释

### 调试技巧

1. 在代码关键位置添加 `console.log()`，便于追踪执行流程
2. 渲染进程按 `Ctrl+R` 刷新，主进程需要重启应用
3. 使用 VS Code 的调试功能（F5），配置 `preLaunchTask` 自动编译
4. 查看 Electron 开发者工具的 Console 标签，可以看到渲染进程的日志
5. 主进程的日志在启动终端中显示

### 文件结构

```
LLExtTool/
├── native/
│   ├── ffmpeg/
│   │   ├── include/         # FFmpeg 头文件
│   │   ├── lib/             # FFmpeg 库文件
│   │   └── bin/             # FFmpeg DLL (61, 59, 5 版本)
│   └── whisper.cpp/
│       ├── build/
│       │   ├── src/Release/ # whisper.lib
│       │   └── bin/         # ggml DLL 文件
│       ├── include/         # 编译时复制 FFmpeg 头文件到这里
│       └── models/          # ggml-large-v2-f16.bin
├── src/
│   ├── main/               # Electron 主进程
│   │   ├── main.ts         # 使用 getMainWindow() 导出
│   │   └── ipc-handlers.ts # dialog.showOpenDialog(mainWindow, ...)
│   ├── renderer/           # 渲染进程
│   │   ├── index.html      # 定义 exports/module
│   │   └── renderer.ts     # 使用 /** */ 中文注释
│   └── shared/
│       └── types.ts
├── binding.gyp             # 正确的路径和 DLL 配置
├── scripts/
│   └── build-native.js     # 复制头文件 + electron-rebuild
└── .vscode/
    ├── launch.json         # F5 调试配置
    └── tasks.json          # 编译任务
```
