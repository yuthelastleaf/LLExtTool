# 模型下载界面实现指南

## 已完成的后端实现

### 1. 模型下载管理器 (`src/main/model-downloader.ts`)

功能：
- ✅ 检查模型下载状态
- ✅ 从 Hugging Face 下载模型
- ✅ 支持下载进度回调
- ✅ 模型存储在用户数据目录
- ✅ 删除和管理模型

### 2. IPC 处理器

已添加的 IPC 通道：
- `GET_MODELS_STATUS` - 获取所有模型状态
- `DOWNLOAD_MODEL` - 下载指定模型
- `DELETE_MODEL` - 删除模型
- `GET_MODEL_PATH` - 获取模型路径

### 3. 模型列表

默认配置的模型：
```typescript
[
  {
    name: 'ggml-large-v2-f16.bin',
    displayName: 'Whisper Large v2 (推荐)',
    size: ~3GB,
    required: true,  // 必需模型
    description: '最高质量的语音识别模型'
  },
  {
    name: 'ggml-medium.bin',
    displayName: 'Whisper Medium',
    size: ~1.5GB,
    required: false,  // 可选模型
    description: '中等大小模型'
  },
  {
    name: 'opus-mt-ja-zh-ct2',
    displayName: '日译中翻译模型',
    size: ~300MB,
    required: false,
    description: '日语到中文的翻译'
  }
]
```

## 需要实现的前端界面

### 1. 模型管理对话框

在 `src/renderer/` 中添加模型管理界面：

```html
<!-- 在 index.html 中添加 -->
<div id="modelManager" class="modal" style="display: none;">
  <div class="modal-content">
    <h2>模型管理</h2>
    <div id="modelList"></div>
    <div class="modal-actions">
      <button id="downloadSelectedModels">下载选中模型</button>
      <button id="closeModelManager">稍后下载</button>
    </div>
  </div>
</div>

<div id="downloadProgress" style="display: none;">
  <h3>正在下载: <span id="currentModelName"></span></h3>
  <progress id="downloadProgressBar" max="100" value="0"></progress>
  <p id="downloadStatus"></p>
</div>
```

### 2. 在 renderer.ts 中添加模型管理逻辑

```typescript
// 检查模型状态
async function checkModels() {
  const models = await window.electron.invoke('get-models-status');
  const missingRequired = models.filter(m => m.required && !m.downloaded);
  
  if (missingRequired.length > 0) {
    showModelManager(models);
  }
}

// 显示模型管理器
function showModelManager(models: ModelInfo[]) {
  const modal = document.getElementById('modelManager');
  const list = document.getElementById('modelList');
  
  list.innerHTML = '';
  models.forEach(model => {
    const item = document.createElement('div');
    item.className = 'model-item';
    item.innerHTML = `
      <input type="checkbox" 
             id="model-${model.name}" 
             ${model.required ? 'checked disabled' : ''}
             ${model.downloaded ? 'disabled' : ''}>
      <label for="model-${model.name}">
        <strong>${model.displayName}</strong>
        <span class="model-size">${formatSize(model.size)}</span>
        ${model.downloaded ? '<span class="badge">已下载</span>' : ''}
        ${model.required ? '<span class="badge required">必需</span>' : ''}
        <p>${model.description}</p>
      </label>
    `;
    list.appendChild(item);
  });
  
  modal.style.display = 'block';
}

// 下载选中的模型
async function downloadSelectedModels() {
  const checkboxes = document.querySelectorAll('#modelList input:checked:not(:disabled)');
  const modelNames = Array.from(checkboxes).map(cb => cb.id.replace('model-', ''));
  
  for (const modelName of modelNames) {
    await downloadModel(modelName);
  }
  
  alert('所有模型下载完成！');
  location.reload();
}

// 下载单个模型
async function downloadModel(modelName: string) {
  const progressDiv = document.getElementById('downloadProgress');
  const progressBar = document.getElementById('downloadProgressBar') as HTMLProgressElement;
  const status = document.getElementById('downloadStatus');
  const nameSpan = document.getElementById('currentModelName');
  
  progressDiv.style.display = 'block';
  nameSpan.textContent = modelName;
  
  // 监听下载进度
  window.electron.on('model-download-progress', (data) => {
    if (data.modelName === modelName) {
      progressBar.value = data.progress;
      status.textContent = `${formatSize(data.downloaded)} / ${formatSize(data.total)}`;
    }
  });
  
  try {
    await window.electron.invoke('download-model', modelName);
  } catch (error) {
    alert(`下载失败: ${error.message}`);
  }
  
  progressDiv.style.display = 'none';
}

// 格式化文件大小
function formatSize(bytes: number): string {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
  return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
}

// 应用启动时检查
window.addEventListener('DOMContentLoaded', () => {
  checkModels();
});
```

### 3. 添加样式

```css
/* 在 main.css 中添加 */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 30px;
  border-radius: 8px;
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}

.model-item {
  padding: 15px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-bottom: 10px;
  display: flex;
  align-items: start;
  gap: 10px;
}

.model-item input[type="checkbox"] {
  margin-top: 5px;
}

.model-item label {
  flex: 1;
}

.model-size {
  color: #666;
  font-size: 0.9em;
  margin-left: 10px;
}

.badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 3px;
  font-size: 0.85em;
  margin-left: 10px;
}

.badge.required {
  background: #ff4444;
  color: white;
}

.modal-actions {
  margin-top: 20px;
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

#downloadProgress {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  min-width: 300px;
}

#downloadProgressBar {
  width: 100%;
  height: 20px;
  margin: 10px 0;
}
```

## 使用流程

1. **用户启动应用**
   ```
   应用启动 → 检查模型 → 发现缺失必需模型 → 显示下载对话框
   ```

2. **用户选择下载**
   ```
   勾选模型 → 点击"下载选中模型" → 显示进度 → 下载完成 → 重新加载
   ```

3. **后续启动**
   ```
   应用启动 → 模型已存在 → 直接加载使用
   ```

## 测试步骤

1. 删除现有模型文件（如果有）
2. 启动应用
3. 应该看到模型下载对话框
4. 选择模型并下载
5. 验证下载进度显示
6. 验证下载完成后能正常使用

## 注意事项

- 模型文件较大（3GB），下载需要时间
- 需要处理下载失败的情况（网络中断等）
- 建议添加暂停/恢复下载功能（进阶）
- 可以添加手动导入模型功能
